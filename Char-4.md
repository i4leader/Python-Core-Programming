## 1. 进程
***
### 1.1 多任务的引入
#### 现实生活中
有很多场景中的事情是同时进行的,比如开车的时候,手和脚共同来驾驶汽车,再比如唱歌跳舞也是同时进行的;   
   
#### 程序中
如下程序,来模拟'唱歌跳舞'这件事情   
```
#coding=utf-8

from time import sleep

def sing():
    for i in range(3):
        print("正在唱歌...%d"%i)
        sleep(1)

def dance():
    for i in range(3):
        print("正在跳舞...%d"%i)

if __name__ == '__main__':
    sing()
    dance()

```   
   
运行结果:   
![dancesing](images/3-4.png)   

### 1.2 多任务的概念
现在,多核CPU已经非常普及了,但是,即使过去的单核CPU,也可以执行多任务. 由于CPU执行代码都是顺序执行的,那么,单核CPU是怎么执行多任务的need?
   
答案就是操作系统轮流让各个人物交替执行,任务1执行0.01秒,切换到任务2,任务2执行0.01秒,再切换到任务3,执行0.01秒....
这样反复执行下去.表面上看,每个任务都是交替执行的,但是,由于CPU的执行速度实在太快了,我们感觉就像所有任务都在同时执行一样.   
真正的并行执行多任务只能在多核CPU上实现,但是,由于任务数量远远多于CPU的核心数量,所以,操作系统也会自动把很多任务轮流调度到每个核心上执行.
   

### 1.3 进程的创建-Fork
#### 1.进程vs程序
编写完毕的代码,在没有运行的时候,称之为程序   
正在运行着的代码,就成为进程   
进程,除了包含代码之外,还有需要运行的环境等,所以和程序是有区别的   
   
#### 2. fork()
Python的os模块封装了常见的系统调用,其中就包括fork,可以在Python程序中轻松创建子进程:   
```
import os

# 注意,fork函数,只在Unix/Linux/Mac 上运行,Windows不可以
pid = os.fork()

if pid == 0:
    print("哈哈1")

else:
    print("哈哈2")

```   
   
运行结果:   
![fork](images/3-5.png)   
   
#### 说明:
* 程序执行到os.fork()时,操作系统会创建一个新的进程(子进程),然后复制父进程的所有信息到子进程中
* 然后父进程和子进程都会从fork()函数中得到一个返回值,在子进程中这个值一定是0, 而父进程中是子进程的id号   
   
在Unix/Linux操作系统中,提供了一个fork()系统函数,它非常特殊.   
普通的函数调用,调用一次,返回一次,但是fork()调用一次,返回两次,因为操作系统自动把当前进程(称为父进程)复制了一份,
(称为子进程),然后,分别在父进程和子进程内返回.   
子进程永远返回0,而父进程返回子进程的ID.   
这样做的理由是,一个父进程可以fork出很多子进程,所以,父进程要记下每个子进程的id,而子进程只需要调用getppid()就可以拿到父进程的id.   
      
#### 3.getpid(),getppid()
```
import os

# 注意,fork函数,只在Unix/Linux/Mac 上运行,Windows不可以
pid = os.fork()
print(pid)
if pid > 0:
    print("---父进程:%d---%d"%(pid, os.getpid()))

else:
    print("-"*50)
    print(pid)
    print("---子进程:%d---pid:%d---ppid:%d"%(pid, os.getpid(), os.getppid()))

```   
   
   
### 1.4 多进程修改全部变量


### 1.5 多次fork的问题


### 1.6 进程的创建-multiprocessing


### 1.7 进程的创建-Process子类


### 1.8 进程池Pool


### 1.9 进程间通信-Queue



## 2. 线程
***

